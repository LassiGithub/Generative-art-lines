/*
    INFORMATION
    -----------

    This is a generative art script. 
    It generates art based on randomness, so you get different results every time you run it.
    You can also adjust the two sliders on the page, or some of the variables in setup(), 
    to get different looking art.

    The way this works is by creating random "points" with perlin noise,
    then interpolating between those points and drawing the resulting lines.

    However, these points don't contain just the regular coordinate information.
    They have 4 indicies, which correspond to different things:
      - point[0]: x-coordinate
      - point[1]: y-coordinate
      - point[2]: radius
      - point[3]: rotation angle

    So in a sense, each point is defined by adding two 2D vectors together:
    A vector in cartesian coordinate system (x and y coordinates),
    and a vector in polar coordinate system (radius and angle).
    The formula for this is in the drawSuperPoint()-method.

    In the script below, these points are called "super points" and "anchor points",
    simply to differentiate them from regular points.

    While the two extra values might seem a bit useless for a point,
    they allow us to interpolate between the points in an interesting way.
    When interpolating between regular points, you usually end up with straight lines.
    However, with these 4 values, the interpolation results in interesting looking curves.

    The art generated by this script works by generating a few random "anchor points",
    then drawing curves by interpolating between them. 

    The randomness is achieved through perlin noise, 
    which allows us to make smooth changes over time and animate them!
    To see the animation, you need to adjust the speed-slider on the page.

    This script uses the open source library p5.js: https://p5js.org/
    This library is meant to simplify creative coding, and it includes some useful functions.
    The biggest reason I used it in this project
    was to get an existing implementation for perlin noise.
*/




// All of these variables are explained and can be adjusted at setup()
let baseCanvasSize;

let xChange;
let yChange;
let radiusChange; 
let angleChange; 
let maxAnchorAmount;  

let pointSize;
let pointsPerLine;
let lengthUnit;
let pointColor;
let bgColor;

let animationTime;
let animationTimeWithoutOffset;
let offsetSlider;
let speedSlider;
let superpoints;
let currentCanvasSize;




/*
    ANIMATION FUNCTIONS
*/

// This function is run once at the start of the animation
function setup() {

  // Change this variable if you want the canvas to be bigger
  baseCanvasSize = 600;

  currentCanvasSize = baseCanvasSize;
  let canv = createCanvas(baseCanvasSize, baseCanvasSize);
  canv.parent("canvas-container");
  fitCanvasToScreen();

  // These variables set the range of possible random values for the anchor points
  // You can change these to get different results
  xChange = 20;
  yChange = 20;
  radiusChange = 20; 
  angleChange = 10; 
  maxAnchorAmount = 8;  

  // These variables set basic things about the drawing
  // You can change these to change the style of it
  pointSize = 1;
  pointsPerLine = 500;
  lengthUnit = 0.04;
  pointColor = color(255);
  bgColor = color(28,28,30);

  // These variables should not be changed
  animationTime = 0;
  animationTimeWithoutOffset = 0;
  offsetSlider = document.getElementById("offset-slider");
  speedSlider = document.getElementById("speed-slider");
  superpoints = [];
}

// This function loops every frame
// In this function we define what we want to draw in the current frame, and draw it
function draw() {
  superpoints = [];
  background(bgColor);
  translate(width/2, height/2);

  // Calculate current animation time based on sliders
  // animationTime is used as a seed for all the random values
  // Since we get the random values from perlin noise, they change smoothly over time
  animationTimeWithoutOffset += parseFloat(speedSlider.value);
  animationTime = animationTimeWithoutOffset + parseFloat(offsetSlider.value);

  // These define how the adjustByCurve() function adjusts a value given to it
  // This is used for making interpolation between anchor points look more interesting
  interpolationCurves = [
    ['p', noise(animationTime+0)],
    ['p', noise(animationTime+1)],
    ['p', noise(animationTime+2)],
    ['p', noise(animationTime+3)]
  ];

  // These variables define the range of possible values for the anchor points at current time
  // They are generated from perlin noise, so these ranges change with time
  let xBase  = noise(animationTime+0) * xChange;
  let yBase  = noise(animationTime+0) * yChange;
  let radiusBase = noise(animationTime+1) * radiusChange;
  let angleBase  = noise(animationTime+2) * angleChange;

  // The amount of anchor points also changes with time
  // We square the noise value to make lower amounts more probable
  // We do the -2 +2 trick to make sure that there's always at least 2 anchor points
  let anchorPointsAmount = (noise(animationTime)**2) * (maxAnchorAmount - 2) + 2;
  anchorPointsAmount = Math.floor(anchorPointsAmount);
  

  // This is where we finally create the list of anchor points
  // The seed for the perlin noise here includes both time and the list index
  // Index is included so that each anchor point in the list will be different
  // Time is included so that the list as a whole changes over time
  for(let i = 0; i<anchorPointsAmount; i++){
    superpoints.push([
      noise(animationTime+i*1) * xBase * 2 - xBase,
      noise(animationTime+i*2) * yBase * 2 - yBase,
      noise(animationTime+i*3) * radiusBase * 2 - radiusBase,
      noise(animationTime+i*4) * angleBase  * 2 - angleBase ]);
  }

  // Interpolate and draw paths between the anchor points
  for(let i = 1; i < superpoints.length; i++){
    drawPathBetweenAnchors(superpoints[i-1], superpoints[i], interpolationCurves, pointsPerLine);
  }
}

// Listener for window resize to resize the canvas
function windowResized() {
  fitCanvasToScreen();
}

// Resizes the canvas according to the window size
function fitCanvasToScreen(){
  let newCanvasSize = baseCanvasSize;

  if (windowWidth < baseCanvasSize + 100){
    newCanvasSize = windowWidth - 100;
  }

  resizeCanvas(newCanvasSize, newCanvasSize);

  currentCanvasSize = newCanvasSize;
}




/*
    SUPER POINT FUNCTIONS
*/

// Draws a path between two anchor points by interpolating between them
function drawPathBetweenAnchors(anchor1, anchor2, interpolationCurves, pointsPerLine){
  for(let i = 0; i<pointsPerLine; i++){
    let t = i/pointsPerLine;
    let pointAtT = interpolateWithCurves(anchor1, anchor2, t, interpolationCurves);
    drawSuperPoint(pointAtT);
  }
}

// Interpolates between two anchor points and returns a new point
function interpolateWithCurves(a, b, t, interpolationCurves){
  let directionVector = vectorDifference(b,a);
  let scaledDirectionVector = vectorScaleWithCurves(directionVector, t, interpolationCurves);
  let finalPoint = vectorSum(a, scaledDirectionVector);

  return finalPoint;
}

function drawSuperPoint(superpoint){
  let x         = superpoint[0] * lengthUnit * currentCanvasSize;
  let y         = superpoint[1] * lengthUnit * currentCanvasSize;
  let radius    = superpoint[2] * lengthUnit * currentCanvasSize;
  let angle     = superpoint[3] * TWO_PI;

  let finalX = x + radius*cos(angle);
  let finalY = y + radius*sin(angle);

  drawNormalPoint(finalX, finalY);
}

function drawNormalPoint(x, y){
  stroke(pointColor);
  strokeWeight(pointSize);

  // We flip the y value to make the coordinates work more like in math (Higher means larger)
  point(x,-y);
}




/*
    MATH FUNCTIONS
*/

// Adds two vectors (lists) together
// The vectors can be any size, as long as their sizes match
function vectorSum(a,b){
    retPoint = [];
  
    for(let i = 0; i<a.length; i++){
      retPoint[i] = a[i] + b[i];
    } 
  
    return retPoint;
}

// Subtracts one vector (list) from another
// The vectors can be any size, as long as their sizes match
function vectorDifference(a,b){
    retPoint = [];
  
    for(let i = 0; i<a.length; i++){
      retPoint[i] = a[i] - b[i];
    }
  
    return retPoint;
}
  
// Scales a vector (list) with a scalar
// The scalar is adjusted by the interpolation curves
// vec.length should equal curveFunctions.length, because the scalar is adjusted differently for each index of vec
// vec should only include values between 0 and 1, because of how adjustByCurve() works
function vectorScaleWithCurves(vec, scalar, curveFunctions){
    finalPoint = [];

    for(let i = 0; i<vec.length; i++) {
      let adjustedScalar = adjustByCurve(scalar, curveFunctions[i]);
      finalPoint[i] = vec[i] * adjustedScalar;
    }

    return finalPoint;
}

// Adjusts a value between 0 and 1 by a curve
function adjustByCurve(x, curve){
    // Input x:
      // Value to be adjusted, between 0 and 1

    // Input curve:
      // List of two elements, [string, number]
      // curve[0] defines which type of curve (function) we adjust with. Possible values: 's' / 'e' / 'l'
      // curve[1] further defines the shape of that curve. To get a sense of what effect this value has, adjust the slider at: https://www.desmos.com/calculator/igdfkrutnk

    // S-Curve
    if (curve[0] === 's'){
      let newX = 1 / ( 1 + ((x/(1-x))**(0 - curve[1])) );
      return newX;
    }
  
    // Power Curve
    if (curve[0] === 'p'){
      let newX = x**(curve[1]);
      return newX;
    }
  
    // Linear Curve, doesn't affect anything
    if (curve[0] === 'l'){
      return x;
    }
}
